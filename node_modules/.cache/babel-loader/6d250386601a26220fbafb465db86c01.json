{"ast":null,"code":"import { useEffect, useMemo, useState } from 'react';\nexport var ZoomState;\n\n(function (ZoomState) {\n  ZoomState[\"ZOOMING_IN\"] = \"ZOOMING_IN\";\n  ZoomState[\"ZOOMING_OUT\"] = \"ZOOMING_OUT\";\n})(ZoomState || (ZoomState = {}));\n\nvar usePinchZoom = function (ref) {\n  var cacheRef = useMemo(function () {\n    return {\n      evCache: [],\n      prevDiff: -1\n    };\n  }, [ref.current]);\n\n  var _a = useState(),\n      zoomingState = _a[0],\n      setZoomingState = _a[1];\n\n  var pointermove_handler = function (ev) {\n    // This function implements a 2-pointer horizontal pinch/zoom gesture.\n    //\n    // If the distance between the two pointers has increased (zoom in),\n    // the target element's background is changed to 'pink' and if the\n    // distance is decreasing (zoom out), the color is changed to 'lightblue'.\n    //\n    // This function sets the target element's border to 'dashed' to visually\n    // indicate the pointer's target received a move event.\n    // Find this event in the cache and update its record with this event\n    for (var i = 0; i < cacheRef.evCache.length; i++) {\n      if (ev.pointerId == cacheRef.evCache[i].pointerId) {\n        cacheRef.evCache[i] = ev;\n        break;\n      }\n    } // If two pointers are down, check for pinch gestures\n\n\n    if (cacheRef.evCache.length == 2) {\n      // console.log(prevDiff)\n      // Calculate the distance between the two pointers\n      var curDiff = Math.abs(cacheRef.evCache[0].clientX - cacheRef.evCache[1].clientX);\n\n      if (cacheRef.prevDiff > 0) {\n        if (curDiff > cacheRef.prevDiff) {\n          // The distance between the two pointers has increased\n          setZoomingState([ZoomState.ZOOMING_IN, curDiff]);\n        }\n\n        if (curDiff < cacheRef.prevDiff) {\n          // The distance between the two pointers has decreased\n          setZoomingState([ZoomState.ZOOMING_OUT, curDiff]);\n        }\n      } // Cache the distance for the next move event\n\n\n      cacheRef.prevDiff = curDiff;\n    }\n  };\n\n  var pointerdown_handler = function (ev) {\n    // The pointerdown event signals the start of a touch interaction.\n    // This event is cached to support 2-finger gestures\n    cacheRef.evCache.push(ev); // console.log('pointerDown', ev);\n  };\n\n  var pointerup_handler = function (ev) {\n    // Remove this pointer from the cache and reset the target's\n    // background and border\n    remove_event(ev); // If the number of pointers down is less than two then reset diff tracker\n\n    if (cacheRef.evCache.length < 2) {\n      cacheRef.prevDiff = -1;\n    }\n  };\n\n  var remove_event = function (ev) {\n    // Remove this event from the target's cache\n    for (var i = 0; i < cacheRef.evCache.length; i++) {\n      if (cacheRef.evCache[i].pointerId == ev.pointerId) {\n        cacheRef.evCache.splice(i, 1);\n        break;\n      }\n    }\n  };\n\n  useEffect(function () {\n    if (ref === null || ref === void 0 ? void 0 : ref.current) {\n      ref.current.onpointerdown = pointerdown_handler;\n      ref.current.onpointermove = pointermove_handler;\n      ref.current.onpointerup = pointerup_handler;\n      ref.current.onpointercancel = pointerup_handler;\n      ref.current.onpointerout = pointerup_handler;\n      ref.current.onpointerleave = pointerup_handler;\n    }\n  }, [ref === null || ref === void 0 ? void 0 : ref.current]);\n  return zoomingState ? {\n    zoomingState: zoomingState[0],\n    pinchState: zoomingState[1]\n  } : {\n    zoomingState: null,\n    pinchState: 0\n  };\n};\n\nexport default usePinchZoom;","map":{"version":3,"sources":["C:/Users/Aditya PC/Downloads/nitsmun2022-23/node_modules/react-use/esm/usePinchZoom.js"],"names":["useEffect","useMemo","useState","ZoomState","usePinchZoom","ref","cacheRef","evCache","prevDiff","current","_a","zoomingState","setZoomingState","pointermove_handler","ev","i","length","pointerId","curDiff","Math","abs","clientX","ZOOMING_IN","ZOOMING_OUT","pointerdown_handler","push","pointerup_handler","remove_event","splice","onpointerdown","onpointermove","onpointerup","onpointercancel","onpointerout","onpointerleave","pinchState"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useState } from 'react';\nexport var ZoomState;\n(function (ZoomState) {\n    ZoomState[\"ZOOMING_IN\"] = \"ZOOMING_IN\";\n    ZoomState[\"ZOOMING_OUT\"] = \"ZOOMING_OUT\";\n})(ZoomState || (ZoomState = {}));\nvar usePinchZoom = function (ref) {\n    var cacheRef = useMemo(function () { return ({\n        evCache: [],\n        prevDiff: -1,\n    }); }, [ref.current]);\n    var _a = useState(), zoomingState = _a[0], setZoomingState = _a[1];\n    var pointermove_handler = function (ev) {\n        // This function implements a 2-pointer horizontal pinch/zoom gesture.\n        //\n        // If the distance between the two pointers has increased (zoom in),\n        // the target element's background is changed to 'pink' and if the\n        // distance is decreasing (zoom out), the color is changed to 'lightblue'.\n        //\n        // This function sets the target element's border to 'dashed' to visually\n        // indicate the pointer's target received a move event.\n        // Find this event in the cache and update its record with this event\n        for (var i = 0; i < cacheRef.evCache.length; i++) {\n            if (ev.pointerId == cacheRef.evCache[i].pointerId) {\n                cacheRef.evCache[i] = ev;\n                break;\n            }\n        }\n        // If two pointers are down, check for pinch gestures\n        if (cacheRef.evCache.length == 2) {\n            // console.log(prevDiff)\n            // Calculate the distance between the two pointers\n            var curDiff = Math.abs(cacheRef.evCache[0].clientX - cacheRef.evCache[1].clientX);\n            if (cacheRef.prevDiff > 0) {\n                if (curDiff > cacheRef.prevDiff) {\n                    // The distance between the two pointers has increased\n                    setZoomingState([ZoomState.ZOOMING_IN, curDiff]);\n                }\n                if (curDiff < cacheRef.prevDiff) {\n                    // The distance between the two pointers has decreased\n                    setZoomingState([ZoomState.ZOOMING_OUT, curDiff]);\n                }\n            }\n            // Cache the distance for the next move event\n            cacheRef.prevDiff = curDiff;\n        }\n    };\n    var pointerdown_handler = function (ev) {\n        // The pointerdown event signals the start of a touch interaction.\n        // This event is cached to support 2-finger gestures\n        cacheRef.evCache.push(ev);\n        // console.log('pointerDown', ev);\n    };\n    var pointerup_handler = function (ev) {\n        // Remove this pointer from the cache and reset the target's\n        // background and border\n        remove_event(ev);\n        // If the number of pointers down is less than two then reset diff tracker\n        if (cacheRef.evCache.length < 2) {\n            cacheRef.prevDiff = -1;\n        }\n    };\n    var remove_event = function (ev) {\n        // Remove this event from the target's cache\n        for (var i = 0; i < cacheRef.evCache.length; i++) {\n            if (cacheRef.evCache[i].pointerId == ev.pointerId) {\n                cacheRef.evCache.splice(i, 1);\n                break;\n            }\n        }\n    };\n    useEffect(function () {\n        if (ref === null || ref === void 0 ? void 0 : ref.current) {\n            ref.current.onpointerdown = pointerdown_handler;\n            ref.current.onpointermove = pointermove_handler;\n            ref.current.onpointerup = pointerup_handler;\n            ref.current.onpointercancel = pointerup_handler;\n            ref.current.onpointerout = pointerup_handler;\n            ref.current.onpointerleave = pointerup_handler;\n        }\n    }, [ref === null || ref === void 0 ? void 0 : ref.current]);\n    return zoomingState\n        ? { zoomingState: zoomingState[0], pinchState: zoomingState[1] }\n        : { zoomingState: null, pinchState: 0 };\n};\nexport default usePinchZoom;\n"]},"metadata":{},"sourceType":"module"}